let a = next 3;;
next((prev a) + (prev a) + 2);;

let eq3 = id{3};;
eq3;;

(* idpeel tests *)

id{7};;

(lam x:((eq{int} (3+4)) (4+3)). x) id{7};;

(* eq{int} (3 + 4) (4 + 3) *)

(* idpeel{3, (x) x + 3};; *)

idpeel{id{3}, (x) lam m: (eq{int} x 3). m};;

(idpeel{id{3}, (x) lam m: ((eq{int} x) 3). m}) (id{1+2});;

(* equality types *)
let ifeq = id{if true then 3 else 4};;

idpeel{id{ifeq}, (x) x};;

(* product type *)
let abs = lam x:int. if x >= 0 then x else (-1 * x);;
(* for all x, abs(x) == abs(abs(x)) *)
(* lam x: int. (id{abs x});; *)

(* sum type *)
let a = next(3 + 4);;
(3, next(3) : sigma x:int. int code);;
(next(4), id{next(3 + 4)} : sigma x: int code. (eq{int code} (next(3 + 4))) (next(3 + prev x)));;
(* (4), id{next(3 + 4)} : sigma x: int code. (eq{int code} (3 + 4)) (3 + prev x));; *)
